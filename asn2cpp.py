#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
asn2cpp_antlr.py
Auto-generates C++11 code from ASN.1 definitions using ANTLR4 grammar.
Relies on generated parser classes in ./parser (ASNParser, ASNLexer, ASNVisitor).
"""

import sys
import os
import datetime
from antlr4 import *
from parser.ASNLexer import ASNLexer
from parser.ASNParser import ASNParser
from parser.ASNVisitor import ASNVisitor

# ---------------------------------------------------------------------
# Helper utilities
# ---------------------------------------------------------------------
def iso_datetime():
    """Return current UTC time in ISO-8601 format."""
    return datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

def header_guard(name: str):
    """Generate include guard from filename."""
    return name.replace(".", "_").upper() + "_"

def cpp_type(asn_type: str) -> str:
    """Rough mapping from ASN.1 type to C++ type."""
    m = {
        "INTEGER": "int",
        "BOOLEAN": "bool",
        "OCTET STRING": "std::vector<uint8_t>",
        "BIT STRING": "std::vector<bool>",
        "VisibleString": "std::string",
        "UTF8String": "std::string",
        "ENUMERATED": "int",
        "CHOICE": "std::variant<>",
        "SEQUENCE": "struct",
        "NULL": "std::monostate",
    }
    return m.get(asn_type, asn_type)

# ---------------------------------------------------------------------
# Visitor that generates C++ code
# ---------------------------------------------------------------------
class CppGenerator(ASNVisitor):
    def __init__(self, module_name):
        self.module_name = module_name
        self.types = []
        self.enums = []
        self.choices = []

    # --- TypeAssignment ------------------------------------------------
    def visitTypeAssignment(self, ctx):
        # Try to extract type name robustly
        name = None
        for c in ctx.getChildren():
            t = str(c)
            if t.isidentifier():
                name = t
                break
        if not name:
            name = "AnonymousType"

        asn = ctx.asnType()
        if asn.builtinType() and asn.builtinType().sequenceType():
            self.types.append((name, asn.builtinType().sequenceType()))
        elif asn.builtinType() and asn.builtinType().enumeratedType():
            self.enums.append((name, asn.builtinType().enumeratedType()))
        elif asn.builtinType() and asn.builtinType().choiceType():
            self.choices.append((name, asn.builtinType().choiceType()))
        return self.visitChildren(ctx)
    
    # --- SEQUENCE ------------------------------------------------------
    def visitSequenceType(self, ctx):
        # handled in visitTypeAssignment
        return None

    # --- CHOICE --------------------------------------------------------
    def visitChoiceType(self, ctx):
        # handled in visitTypeAssignment
        return None

    # --- ENUMERATED ----------------------------------------------------
    def visitEnumeratedType(self, ctx):
        # handled in visitTypeAssignment
        return None

    # ------------------------------------------------------------------
    def generate(self):
        hpp_name = f"{self.module_name}.hpp"
        cpp_name = f"{self.module_name}.cpp"
        guard = header_guard(hpp_name)
        date_str = iso_datetime()

        # --- HEADER FILE ---
        hpp = []
        hpp.append(f"/**")
        hpp.append(f" * @file {hpp_name}")
        hpp.append(f" * @brief Auto-generated C++ types from ASN.1 module {self.module_name}")
        hpp.append(f" * @date {date_str}")
        hpp.append(f" * @generated by asn2cpp_antlr.py")
        hpp.append(f" */\n")
        hpp.append(f"#ifndef {guard}")
        hpp.append(f"#define {guard}\n")
        hpp.append("#include <string>")
        hpp.append("#include <vector>")
        hpp.append("#include <variant>")
        hpp.append("#include <cstdint>\n")
        hpp.append("namespace DLMS {\n")

        # --- ENUMERATED TYPES ---
        for name, enum_ctx in self.enums:
            hpp.append(f"/** @brief ENUMERATED type {name} */")
            hpp.append(f"enum class {name} {{")
            if enum_ctx.enumerations() and enum_ctx.enumerations().rootEnumeration():
                root_enum = enum_ctx.enumerations().rootEnumeration()
                enum_items = root_enum.enumeration()

                if not isinstance(enum_items, (list, tuple)):
                    enum_items = [enum_items]

                items = []
                for e in enum_items:
                    if e.namedNumber() and e.namedNumber().IDENTIFIER():
                        ident = e.namedNumber().IDENTIFIER().getText()
                    else:
                        ident = "Unnamed"
                    items.append(f"  {ident}")
                hpp.append(",\n".join(items))
            hpp.append("};\n")

        # --- SEQUENCE TYPES ---
        for name, seq_ctx in self.types:
            hpp.append(f"/** @brief SEQUENCE type {name} */")
            hpp.append(f"struct {name} {{")
            if seq_ctx.componentTypeLists():
                for comp in seq_ctx.componentTypeLists().componentTypeList().componentType():
                    field_name = comp.namedType().IDENTIFIER().getText()
                    field_type = comp.namedType().asnType().getText()
                    cpp_field_type = cpp_type(field_type)
                    hpp.append(f"  /** @brief Field {field_name} of type {field_type} */")
                    hpp.append(f"  {cpp_field_type} {field_name};")
            hpp.append("")
            hpp.append("  /** @brief Encode this structure to ASN.1 binary form */")
            hpp.append("  std::vector<uint8_t> encode() const;")
            hpp.append("  /** @brief Decode this structure from ASN.1 binary form */")
            hpp.append("  bool decode(const std::vector<uint8_t>& data);")
            hpp.append("};\n")

        # --- CHOICE TYPES ---
        for name, ch_ctx in self.choices:
            hpp.append(f"/** @brief CHOICE type {name} */")
            hpp.append(f"struct {name} {{")
            hpp.append("  /** @brief Variant of all possible alternatives */")
            alts = []
            if ch_ctx.alternativeTypeLists() and ch_ctx.alternativeTypeLists().rootAlternativeTypeList():
                for alt in ch_ctx.alternativeTypeLists().rootAlternativeTypeList().namedType():
                    field_type = cpp_type(alt.asnType().getText())
                    alts.append(field_type)
            variant_decl = "std::variant<" + ", ".join(alts) + ">"
            hpp.append(f"  {variant_decl} value;")
            hpp.append("")
            hpp.append("  std::vector<uint8_t> encode() const;")
            hpp.append("  bool decode(const std::vector<uint8_t>& data);")
            hpp.append("};\n")

        hpp.append("} // namespace DLMS\n")
        hpp.append(f"#endif // {guard}\n")

        # --- CPP FILE ---
        cpp = []
        cpp.append(f"/**")
        cpp.append(f" * @file {cpp_name}")
        cpp.append(f" * @brief Implementation of encode/decode for ASN.1 module {self.module_name}")
        cpp.append(f" * @date {date_str}")
        cpp.append(f" * @generated by asn2cpp_antlr.py")
        cpp.append(f" */\n")
        cpp.append(f'#include "{hpp_name}"')
        cpp.append("namespace DLMS {\n")
        for name, seq_ctx in self.types:
            cpp.append(f"std::vector<uint8_t> {name}::encode() const {{")
            cpp.append("  // TODO: implement ASN.1 DER/BER encoder")
            cpp.append("  return {};")
            cpp.append("}\n")
            cpp.append(f"bool {name}::decode(const std::vector<uint8_t>& data) {{")
            cpp.append("  // TODO: implement ASN.1 DER/BER decoder")
            cpp.append("  (void)data; return true;")
            cpp.append("}\n")
        cpp.append("} // namespace DLMS\n")

        # --- Write files ---
        with open(hpp_name, "w", encoding="utf-8") as f:
            f.write("\n".join(hpp))
        with open(cpp_name, "w", encoding="utf-8") as f:
            f.write("\n".join(cpp))
        print(f"Generated: {hpp_name}, {cpp_name}")


# ---------------------------------------------------------------------
# Main entry
# ---------------------------------------------------------------------
def main():
    if len(sys.argv) < 2:
        print("Usage: asn2cpp_antlr.py <input.asn>")
        sys.exit(1)

    input_file = sys.argv[1]
    module_name = os.path.splitext(os.path.basename(input_file))[0]

    input_stream = FileStream(input_file, encoding="utf-8")
    lexer = ASNLexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = ASNParser(stream)
    tree = parser.moduleDefinition()

    visitor = CppGenerator(module_name)
    visitor.visit(tree)
    visitor.generate()

if __name__ == "__main__":
    main()
