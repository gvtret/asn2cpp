#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
asn2cpp_antlr.py
Auto-generates C++11 code from ASN.1 definitions using ANTLR4 grammar.
Relies on generated parser classes in ./parser (ASNParser, ASNLexer, ASNVisitor).
"""

import sys
import os
import datetime
from antlr4 import *
from parser.ASNLexer import ASNLexer
from parser.ASNParser import ASNParser
from parser.ASNVisitor import ASNVisitor


# ---------------------------------------------------------------------
# Helper utilities
# ---------------------------------------------------------------------
def iso_datetime():
    """Return current UTC time in ISO-8601 format."""
    return datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")


def header_guard(name: str):
    """Generate include guard from filename."""
    return name.replace(".", "_").replace("-", "_").upper() + "_"


def sanitize_identifier(name: str) -> str:
    """Replace characters that are invalid in C++ identifiers."""
    if not name:
        return name
    return name.replace("-", "_")


def cpp_type(asn_type: str) -> str:
    """Rough mapping from ASN.1 type to C++ type."""
    m = {
        "INTEGER": "int",
        "BOOLEAN": "bool",
        "OCTET STRING": "std::vector<uint8_t>",
        "BIT STRING": "std::vector<bool>",
        "VisibleString": "std::string",
        "UTF8String": "std::string",
        "ENUMERATED": "int",
        "CHOICE": "std::variant<>",
        "SEQUENCE": "struct",
        "NULL": "std::monostate",
    }
    return m.get(asn_type, sanitize_identifier(asn_type))


# ---------------------------------------------------------------------
# Visitor that generates C++ code
# ---------------------------------------------------------------------
class CppGenerator(ASNVisitor):
    def __init__(self, module_name):
        self.module_name = module_name
        self.types = []
        self.enums = []
        self.choices = []

    # --- TypeAssignment ------------------------------------------------
    def visitTypeAssignment(self, ctx):
        # Try to extract type name from the parent assignment context
        name = None
        parent = getattr(ctx, "parentCtx", None)
        if parent and hasattr(parent, "IDENTIFIER"):
            ident = parent.IDENTIFIER()
            if ident:
                name = ident.getText()
        if not name:
            # Fallback to scanning the children for an identifier token
            for c in ctx.getChildren():
                token_text = str(c)
                if token_text.isidentifier():
                    name = token_text
                    break
        if not name:
            name = "AnonymousType"
        name = sanitize_identifier(name)

        asn = ctx.asnType()
        if asn.builtinType() and asn.builtinType().sequenceType():
            self.types.append((name, asn.builtinType().sequenceType()))
        elif asn.builtinType() and asn.builtinType().enumeratedType():
            self.enums.append((name, asn.builtinType().enumeratedType()))
        elif asn.builtinType() and asn.builtinType().choiceType():
            self.choices.append((name, asn.builtinType().choiceType()))
        return self.visitChildren(ctx)

    # --- SEQUENCE ------------------------------------------------------
    def visitSequenceType(self, ctx):
        # handled in visitTypeAssignment
        return None

    # --- CHOICE --------------------------------------------------------
    def visitChoiceType(self, ctx):
        # handled in visitTypeAssignment
        return None

    # --- ENUMERATED ----------------------------------------------------
    def visitEnumeratedType(self, ctx):
        # handled in visitTypeAssignment
        return None

    # ------------------------------------------------------------------
    def generate(self):
        hpp_name = f"{self.module_name}.hpp"
        cpp_name = f"{self.module_name}.cpp"
        guard = header_guard(hpp_name)
        date_str = iso_datetime()

        # --- HEADER FILE ---
        hpp = []
        hpp.append(f"/**")
        hpp.append(f" * @file {hpp_name}")
        hpp.append(
            f" * @brief Auto-generated C++ types from ASN.1 module {self.module_name}"
        )
        hpp.append(f" * @date {date_str}")
        hpp.append(f" * @generated by asn2cpp_antlr.py")
        hpp.append(f" */\n")
        hpp.append(f"#ifndef {guard}")
        hpp.append(f"#define {guard}\n")
        hpp.append("#include <string>")
        hpp.append("#include <vector>")
        hpp.append("#include <variant>")
        hpp.append("#include <cstdint>\n")
        hpp.append("namespace DLMS {\n")

        # --- ENUMERATED TYPES ---
        for name, enum_ctx in self.enums:
            hpp.append(f"/** @brief ENUMERATED type {name} */")
            hpp.append(f"enum class {name} {{")
            items = []
            if enum_ctx.enumerations() and enum_ctx.enumerations().rootEnumeration():
                enumeration = enum_ctx.enumerations().rootEnumeration().enumeration()
                if enumeration:
                    for item_ctx in enumeration.enumerationItem():
                        ident = None
                        if item_ctx.IDENTIFIER():
                            ident = item_ctx.IDENTIFIER().getText()
                        elif (
                            item_ctx.namedNumber()
                            and item_ctx.namedNumber().IDENTIFIER()
                        ):
                            ident = item_ctx.namedNumber().IDENTIFIER().getText()
                        elif item_ctx.value():
                            ident = item_ctx.value().getText()
                        if not ident:
                            ident = "Unnamed"
                        items.append(f"  {sanitize_identifier(ident)}")
            if items:
                hpp.append(",\n".join(items))
            hpp.append("};\n")

        # --- SEQUENCE TYPES ---
        for name, seq_ctx in self.types:
            hpp.append(f"/** @brief SEQUENCE type {name} */")
            hpp.append(f"struct {name} {{")
            if seq_ctx.componentTypeLists():
                comp_lists = seq_ctx.componentTypeLists().rootComponentTypeList()
                if not isinstance(comp_lists, (list, tuple)):
                    comp_lists = [comp_lists]
                for comp_list in comp_lists:
                    if not comp_list:
                        continue
                    ct_list = comp_list.componentTypeList()
                    if not ct_list:
                        continue
                    for comp in ct_list.componentType():
                        named = comp.namedType()
                        if not named:
                            continue
                        if not named.IDENTIFIER():
                            continue
                        field_name = sanitize_identifier(named.IDENTIFIER().getText())
                        field_type = named.asnType().getText()
                        cpp_field_type = cpp_type(field_type)
                        hpp.append(
                            f"  /** @brief Field {field_name} of type {field_type} */"
                        )
                        hpp.append(f"  {cpp_field_type} {field_name};")
            hpp.append("")
            hpp.append("  /** @brief Encode this structure to ASN.1 binary form */")
            hpp.append("  std::vector<uint8_t> encode() const;")
            hpp.append("  /** @brief Decode this structure from ASN.1 binary form */")
            hpp.append("  bool decode(const std::vector<uint8_t>& data);")
            hpp.append("};\n")

        # --- CHOICE TYPES ---
        for name, ch_ctx in self.choices:
            hpp.append(f"/** @brief CHOICE type {name} */")
            hpp.append(f"struct {name} {{")
            hpp.append("  /** @brief Variant of all possible alternatives */")
            alts = []
            if ch_ctx.alternativeTypeLists():
                root_alts = ch_ctx.alternativeTypeLists().rootAlternativeTypeList()
                if not isinstance(root_alts, (list, tuple)):
                    root_alts = [root_alts]
                for root_alt in root_alts:
                    if not root_alt:
                        continue
                    alt_list = root_alt.alternativeTypeList()
                    if not alt_list:
                        continue
                    for alt in alt_list.namedType():
                        if not alt.asnType():
                            continue
                        field_type = cpp_type(alt.asnType().getText())
                        alts.append(field_type)
            variant_decl = "std::variant<" + ", ".join(alts) + ">"
            hpp.append(f"  {variant_decl} value;")
            hpp.append("")
            hpp.append("  std::vector<uint8_t> encode() const;")
            hpp.append("  bool decode(const std::vector<uint8_t>& data);")
            hpp.append("};\n")

        hpp.append("} // namespace DLMS\n")
        hpp.append(f"#endif // {guard}\n")

        # --- CPP FILE ---
        cpp = []
        cpp.append(f"/**")
        cpp.append(f" * @file {cpp_name}")
        cpp.append(
            f" * @brief Implementation of encode/decode for ASN.1 module {self.module_name}"
        )
        cpp.append(f" * @date {date_str}")
        cpp.append(f" * @generated by asn2cpp_antlr.py")
        cpp.append(f" */\n")
        cpp.append(f'#include "{hpp_name}"')
        cpp.append("namespace DLMS {\n")
        for name, seq_ctx in self.types:
            cpp.append(f"std::vector<uint8_t> {name}::encode() const {{")
            cpp.append("  // TODO: implement ASN.1 DER/BER encoder")
            cpp.append("  return {};")
            cpp.append("}\n")
            cpp.append(f"bool {name}::decode(const std::vector<uint8_t>& data) {{")
            cpp.append("  // TODO: implement ASN.1 DER/BER decoder")
            cpp.append("  (void)data; return true;")
            cpp.append("}\n")
        cpp.append("} // namespace DLMS\n")

        # --- Write files ---
        with open(hpp_name, "w", encoding="utf-8") as f:
            f.write("\n".join(hpp))
        with open(cpp_name, "w", encoding="utf-8") as f:
            f.write("\n".join(cpp))
        print(f"Generated: {hpp_name}, {cpp_name}")


# ---------------------------------------------------------------------
# Main entry
# ---------------------------------------------------------------------
def main():
    if len(sys.argv) < 2:
        print("Usage: asn2cpp_antlr.py <input.asn>")
        sys.exit(1)

    input_file = sys.argv[1]
    module_name = os.path.splitext(os.path.basename(input_file))[0]

    input_stream = FileStream(input_file, encoding="utf-8")
    lexer = ASNLexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = ASNParser(stream)
    tree = parser.moduleDefinition()

    visitor = CppGenerator(module_name)
    visitor.visit(tree)
    visitor.generate()


if __name__ == "__main__":
    main()
